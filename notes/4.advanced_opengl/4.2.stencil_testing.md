# 4.2 模板测试

## 概念

大体上是，在模板缓冲里维护每个像素的值（8 位），然后渲染出来的片段根据模板值来决定去留。不是所有窗口库都像 GLFW 一样自动配置模板缓冲。

感觉有些类似遮罩。模板测试一般的流程是：

1. 启用模板缓冲写入
2. 渲染部分物体，更新模板缓冲的值
3. 关闭写入
4. 渲染其他物体，根据模板缓冲的内容丢弃片段

## 流程控制

可以使用 `glStencilMask()` 指定模板缓冲的位掩码，用于和通过测试的模板值进行按位与，然后再写到模板缓冲里。默认的是 0xFF，无影响。如果初始化为 0x00 就会有禁用写入的效果。可以设定为其他值来保护特定位，但一般不会用到。注意这个值会影响 `glClear` 清除缓冲的效果。

用 `glStencilFunc` 控制模板测试函数（`GL_EQUAL` 等等）、参考值（比较值）和掩码（参考值和缓冲值都先经过掩码再比较）。例如“模板值等于 1 的片段将通过测试”可以写成 `glStencilFunc(GL_EQUAL, 1, 0xFF)`。

用`glStencilOp` 控制模板测试的各种情况下如何更新缓冲。三个参数分别控制：

- 模板测试失败（sfail）
- 模板测试通过，深度测试失败（dpfail）
- 模板测试和深度测试都失败（dppass）

下的行为。可以有：

|行为|描述|
|:-:|:-:|
|`GL_KEEP`|保留储存的模板值|
|`GL_ZERO`|模板值置零|
|`GL_REPLACE`|模板值设为 `glStencilFunc` 设置的参考值|
|`GL_INCR`|模板值加一，但不超过最大值|
|`GL_INCR_WARP`|模板值加一，超过最大值则归零|
|`GL_DECR`|模板值减一，但不超过最小值|
|`GL_DECR_WARP`|模板值减一，超过最小值则置最大值|
|`GL_INVERT`|模板值按位取反|

默认的策略是三个 KEEP。控制的粒度还是比较固定的，不是很灵活。

## 应用：物体轮廓绘制

模板测试是个比较抽象的东西，实际上怎么用完全取决于要实现什么效果。

下面实现一个物体轮廓效果，流程是：

1. 模板函数通过所有值，并将通过的缓冲值置 1。
2. 绘制物体（实际显示的）
3. 禁用模板写入和深度测试（使轮廓总在最前方）
4. 使用片段着色器输出轮廓颜色
5. 将物体顶点按法线方向偏移一点，在模板值不等于 1 的区域绘制物体（实际只是单色）
6. 启用模板写入和深度测试（其他正常渲染）

实际上就是绘制了一个可见性有点奇怪的更大的模型，额外占用一次绘制，因此存在看不见模型但是能看见这个大轮廓的时候。

注意一些细节，比如第一次绘制的实际方块如果启用了深度测试，就会因为地板等前景片段的阻挡而没法更新全部的模板缓冲，之后再取消深度去绘制的轮廓会显示出被遮挡的部分，而且是一大片（因为就是把模型重新绘制了一遍）。如果在绘制轮廓的时候启用深度测试，轮廓（模型）也会被遮挡，看起来自然一点。如果想要轮廓线完整显示，需要在更新模板缓冲的时候忽略深度测试结果，然后在绘制轮廓时关闭深度测试。

其他的应用，比如填充式的绘制，或者使用 shadow volume 来渲染实时阴影。