# 几何着色器

几何着色器夹在顶点着色器和片段着色器之间，接收某种图元的一系列顶点（即所有顶点）并对其进行任意的修改，甚至可以输出为其他类型的图元。

需要在输入关键字 `in` 前指定图元类型

|         类型          |                        适用图元                         | 最小顶点数 |
| :-------------------: | :-----------------------------------------------------: | :--------: |
|       `points`        |                       `GL_POINTS`                       |     1      |
|        `lines`        |               `GL_LINES`, `GL_LINE_STRIP`               |     2      |
|   `lines_adjacency`   |     `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`     |     4      |
|      `triangles`      | `GL_TRIANGLES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`  |     3      |
| `triangles_adjacency` | `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` |     6      |

例：`layout (points) in;`

输出也需要指定

- `points`
- `line_strip`
- `triangle_strip`

且要指定最大定点数量 `max_vertices`。超过这个值的顶点不会被绘制。

例：`layout (triangle_strip, max_vertices = 3) out;`

OpenGL 提供了一个内置的接口块数组存放输入数据（具体见文档）：

```cpp
in gl_Vertex
{
    vec4  gl_Position;
    float gl_PointSize;
    float gl_ClipDistance[];
} gl_in[];
```

输出数据则是给到全局定义的那些变量。

结束一个顶点的编辑后，使用 `EmitVertex()` 提交顶点。提交足够的顶点后，使用 `EndPrimitive()` 提交一个图元。注意顶点数据和哪个顶点绑定，不更新数据时后续顶点可能使用遗留在那个字段里的数据，比如在系列顶点的一开始设置一次顶点颜色。

顶点着色器接受的数据总是数组形式的，无论是内置的 `gl_in[]` 还是自建的接口块。

# 使用

由于几何着色器在GPU中执行，显然会比把数据buffer到GPU里面要快，很容易想到只把位置等关键参数喂给顶点着色器，然后使用几何着色器生成其他的顶点。

在可视化法向量时，注意几何着色器接受了观察空间下的坐标（因为顶点着色器只乘了M和V矩阵），所以法向量矩阵要注意变换。法向量总要保持垂直。

同样因为矩阵变换的问题，位移（爆炸）图元那个例子里的顶点着色器会导致三角面有奇怪的位移和消失现象。因为顶点位置经过了完整的变换，以这些数据来计算法向量的结果就是很怪异的移动轨迹（非线性空间）。直接操作模型本身最好还是在模型空间完成。